|.arch x64
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|.define X64, 1
|.if WIN
|.define X64WIN, 1
|.endif
|
|// Fixed register assignments for the interpreter.
|// This is very fragile and has many dependencies. Caveat emptor.
|.define BASE,		edx		// Not C callee-save, refetched anyway.
|.if X64WIN
|.define KBASE,		edi		// Must be C callee-save.
|.define KBASEa,	rdi
|.define PC,		esi		// Must be C callee-save.
|.define PCa,		rsi
|.define DISPATCH,	ebx		// Must be C callee-save.
|.else
|.define KBASE,		r15d		// Must be C callee-save.
|.define KBASEa,	r15
|.define PC,		ebx		// Must be C callee-save.
|.define PCa,		rbx
|.define DISPATCH,	r14d		// Must be C callee-save.
|.endif
|
|.define RA,		ecx
|.define RAH,		ch
|.define RAL,		cl
|.define RB,		ebp		// Must be ebp (C callee-save).
|.define RC,		eax		// Must be eax.
|.define RCW,		ax
|.define RCH,		ah
|.define RCL,		al
|.define OP,		RB
|.define RD,		RC
|.define RDW,		RCW
|.define RDL,		RCL
|.define RAa, rcx
|.define RBa, rbp
|.define RCa, rax
|.define RDa, rax
|
|.if X64WIN
| // On Win64, integer arguments are passed in registers RCX, RDX, R8, and R9.
|.define CARG1,		rcx		// x64/WIN64 C call arguments.
|.define CARG2,		rdx
|.define CARG3,		r8
|.define CARG4,		r9
|.define CARG1d,	ecx
|.define CARG2d,	edx
|.define CARG3d,	r8d
|.define CARG4d,	r9d
|.define FCARG1,	CARG1d		// Upwards compatible to x86 fastcall.
|.define FCARG2,	CARG2d
|.else
|.define CARG1,		rdi		// x64/POSIX C call arguments.
|.define CARG2,		rsi
|.define CARG3,		rdx
|.define CARG4,		rcx
|.define CARG5,		r8
|.define CARG6,		r9
|.define CARG1d,	edi
|.define CARG2d,	esi
|.define CARG3d,	edx
|.define CARG4d,	ecx
|.define CARG5d,	r8d
|.define CARG6d,	r9d
|.define FCARG1,	CARG1d		// Simulate x86 fastcall.
|.define FCARG2,	CARG2d
|.endif
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State
|.type GL,		global_State
|.type TVALUE,		TValue
|
|// Stack layout while in interpreter. 
|//-----------------------------------------------------------------------
|.if X64WIN		// x64/Windows stack layout
|
|.define CFRAME_SPACE,	aword*5			// Delta for rsp (see <--).
|.macro saveregs_
|  // The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15 are considered nonvolatile 
|  // and must be saved and restored by a function that uses them.
|  push rdi; push rsi; push rbx
|  push r12; push r13; push r14; push r15;
|  sub rsp, CFRAME_SPACE
|.endmacro
|.macro saveregs
|  push rbp; saveregs_
|.endmacro
|.macro restoreregs
|  add rsp, CFRAME_SPACE
|  pop r15; pop r14; pop r13; pop r12;
|  pop rbx; pop rsi; pop rdi; pop rbp
|.endmacro
|
|.define SAVE_CFRAME,	aword [rsp+aword*13]
|.define SAVE_PC,	dword [rsp+dword*25]
|.define SAVE_L,	dword [rsp+dword*24]
|.define SAVE_ERRF,	dword [rsp+dword*23]
|.define SAVE_NRES,	dword [rsp+dword*22]
|.define TMP2,		dword [rsp+dword*21]
|.define TMP1,		dword [rsp+dword*20]
|//----- 16 byte aligned, ^^^ 32 byte register save area, owned by interpreter
|.define SAVE_RET,	aword [rsp+aword*9]	//<-- rsp entering interpreter.
|.define SAVE_R4,	aword [rsp+aword*8]
|.define SAVE_R3,	aword [rsp+aword*7]
|.define SAVE_R2,	aword [rsp+aword*6]
|.define SAVE_R1,	aword [rsp+aword*5]	//<-- rsp after register saves.
|.define ARG5,		aword [rsp+aword*4]
|.define CSAVE_4,	aword [rsp+aword*3]
|.define CSAVE_3,	aword [rsp+aword*2]
|.define CSAVE_2,	aword [rsp+aword*1]
|.define CSAVE_1,	aword [rsp]		//<-- rsp while in interpreter.
|//----- 16 byte aligned, ^^^ 32 byte register save area, owned by callee
|
|// TMPQ overlaps TMP1/TMP2. MULTRES overlaps TMP2 (and TMPQ).
|.define TMPQ,		qword [rsp+aword*10]
|.define MULTRES,	TMP2
|.define TMPa,		ARG5
|.define ARG5d,		dword [rsp+aword*4]
|.define TMP3,		ARG5d
|
|//-----------------------------------------------------------------------
|.else			// x64/POSIX stack layout
|
|.define CFRAME_SPACE,	aword*5			// Delta for rsp (see <--).
|.macro saveregs_
|  push rbp; push rbx; push r15; push r14; 
|  push r13; push r12
|  sub rsp, CFRAME_SPACE
|.endmacro
|.macro saveregs
|  push rbp; saveregs_
|.endmacro
|.macro restoreregs
|  add rsp, CFRAME_SPACE
|  pop r12; pop r13
|  pop r14; pop r15; pop rbx; pop rbp
|.endmacro
|
|//----- 16 byte aligned,
|.if NO_UNWIND
|.define SAVE_RET,	aword [rsp+aword*11]	//<-- rsp entering interpreter.
|.define SAVE_R4,	aword [rsp+aword*10]
|.define SAVE_R3,	aword [rsp+aword*9]
|.define SAVE_R2,	aword [rsp+aword*8]
|.define SAVE_R1,	aword [rsp+aword*7]
|.define SAVE_RU2,	aword [rsp+aword*6]
|.define SAVE_RU1,	aword [rsp+aword*5]	//<-- rsp after register saves.
|.else
|.define SAVE_RET,	aword [rsp+aword*9]	//<-- rsp entering interpreter.
|.define SAVE_R4,	aword [rsp+aword*8]
|.define SAVE_R3,	aword [rsp+aword*7]
|.define SAVE_R2,	aword [rsp+aword*6]
|.define SAVE_R1,	aword [rsp+aword*5]	//<-- rsp after register saves.
|.endif
|.define SAVE_CFRAME,	aword [rsp+aword*4]
|.define SAVE_PC,	dword [rsp+dword*7]
|.define SAVE_L,	dword [rsp+dword*6]
|.define SAVE_ERRF,	dword [rsp+dword*5]
|.define SAVE_NRES,	dword [rsp+dword*4]
|.define TMPa,		aword [rsp+aword*1]
|.define TMP2,		dword [rsp+dword*1]
|.define TMP1,		dword [rsp]		//<-- rsp while in interpreter.
|//----- 16 byte aligned
|
|// TMPQ overlaps TMP1/TMP2. MULTRES overlaps TMP2 (and TMPQ).
|.define TMPQ,		qword [rsp]
|.define TMP3,		dword [rsp+aword*1]
|.define MULTRES,	TMP2
|
|.endif

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  |.code_sub
  |
  |//-----------------------------------------------------------------------
  |//-- Return handling ----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_leave_unw:
  |  restoreregs
  |  ret
}
/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, OpCode op, int defop)
{
  int vk = 0;
  |// Note: aligning all instructions does not pay off.
  |=>defop:

  switch (op) {

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode %d\n", (int)op); // luaP_opnames[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;
  dasm_growpc(Dst, NUM_OPCODES);
  build_subroutines(ctx);
  |.code_op
  for (op = 0; op < NUM_OPCODES; op++)
    build_ins(ctx, (OpCode)op, op);
  return NUM_OPCODES;
}

