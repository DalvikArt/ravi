/*
Introduction
============

This is the code generator for the Lua/Ravi VM. It uses dynasm as the assembler. 
The overall approach is:

* For each bytecode create an assembler routine
* Create a dispatch table with pointers to the assembler routines
* Each assembler routine will fetch the next bytecode instruction and jump to the next assembler routine using the dispatch table
* The assembler routines are not full fledged C functions - they are part of one whole program. Hence they make assumptions about
  register usage which will be documented below. The VM as a whole will have a fixed set of register allocations so that most 
  important information is held in registers. 
  
Design Considerations
---------------------
* We will use 64-bit pointers and operations mostly - and not try to squeeze pointers into 32-bit regisers as LuaJIT appears to do.
* The dispatch table will be stored in global_State - it is not clear yet whether it is worth making a local stack copy of it when the
  VM starts executing.

Register Allocations
--------------------
The VM will use a fixed set of registers mostly with some register usage varying across routines. The following table shows the
planned usage. 

Nomenclature

* cs - callee saved, if we call a C function then after it returns we can rely on these registers
* v - volatile, these registers may be overridden by a called function so do not rely on them after function call
* (n) - used to pass arg n to function

+--------------------+------------------+------------------------------+------------------------------------------+
+ Windows X64 reg    + Linux X64 reg    + Assignment                   + Notes                                    +
+====================+==================+==============================+==========================================+
+ rbx (cs)           + rbx (cs)         + PC (ebx)                     + Lua byte code offset                     +
+--------------------+------------------+------------------------------+------------------------------------------+
+ rbp (cs)           + rbp (cs)         + L                            +                                          +
+--------------------+------------------+------------------------------+------------------------------------------+
+ rdi (cs)           + rdi (v) (1)      + TMP1                         + Scratch                                  +
+--------------------+------------------+------------------------------+------------------------------------------+
+ rsi (cs)           + rsi (v) (2)      + TMP2                         + Scratch                                  +
+--------------------+------------------+------------------------------+------------------------------------------+
+ rsp (cs)           + rsp              +                              + Stack pointer                            +
+--------------------+------------------+------------------------------+------------------------------------------+
+ r12 (cs)           + r12 (cs)         + CI                           + CallInfo (Lua frame)                     +
+--------------------+------------------+------------------------------+------------------------------------------+
+ r13 (cs)           + r13 (cs)         + LCL                          + LuaClosure                               +
+--------------------+------------------+------------------------------+------------------------------------------+
+ r14 (cs)           + r14 (cs)         + DISPATCH                     + Ptr to Dispatch table                    +
+--------------------+------------------+------------------------------+------------------------------------------+
+ r15 (cs)           + r15 (cs)         + KBASE                        + Ptr to constants table in Proto          +
+--------------------+------------------+------------------------------+------------------------------------------+
+ rax (v)            + rax (v)          + RCa                          + Scratch - upon entry to subroutine eax   +
+                    +                  +                              + will have the B,C portion of bytecode    +
+--------------------+------------------+------------------------------+------------------------------------------+
+ rcx (v) (1)        + rcx (v) (4)      + RAa                          + Scratch - upon entry to subroutine ecx   +
+                    +                  +                              + will have the value of A in bytecode     +
+--------------------+------------------+------------------------------+------------------------------------------+
+ rdx (v) (2)        + rdx (v) (3)      + RBa                          + Scratch - upon entry to subroutine edx   +
+                    +                  +                              + will have the OpCode                     +
+--------------------+------------------+------------------------------+------------------------------------------+
+ r8 (v) (3)         + r8 (v) (5)       + BASE                         + Lua stack base                           +
+--------------------+------------------+------------------------------+------------------------------------------+
+ r9 (v) (4)         + r9 (v) (6)       + TMP3                         + Scratch                                  +
+--------------------+------------------+------------------------------+------------------------------------------+

Stack space 
-----------
On Win64 every function gets a 32-byte shadow space for the 4 register arguments, which we can use. But we also need
to provide a shadow space for function calls inside the VM. 

We can size the stack such that we pre-allocate the 32 byte shadow space on Win64, so that we don't need to adjust the 
stack every time we make a call to a C function. But instead of using this we use the shadow space provided by the caller.

*/
|.arch x64
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|.define X64, 1
|.if WIN
|.define X64WIN, 1
|.endif
|
|// Fixed register assignments for the interpreter.
|// This is very fragile and has many dependencies. Caveat emptor.
|// BASE caches the Lua function's base pointer (start of Lua registers)
|// This is volatile, i.e. must be refetched after any call that can
|// reallocate the Lua stack (typically any Lua api call)
|// KBASE caches the Lua function proto's constant table, this does not
|// change during the execution
|// PC caches the program counter (current bytecode location)
|// We need to ensure that the PC is saved before calling certain functions
|// DISPATCH points to the dispatch table which is located in the 
|// global_State structure defined in lstate.h - this contains the computed goto
|// destinations
|.define BASE,		r8		  // Not C callee-save, refetched anyway.
|.define KBASE,		r15		  // Must be C callee-save.
|.define PC,		rbx		    // Must be C callee-save.
|.define DISPATCH,	r14	// Must be C callee-save.
|
|.define RA,  ecx
|.define RAH, ch
|.define RAL, cl
|.define RAa, rcx
|.define RC,  eax         // volatile
|.define RCH, ah
|.define RCL, al
|.define RCW, ax
|.define RCa, rax
|.define RB,  edx
|.define RBH, dh
|.define RBL, dl
|.define RBa, rdx
|.define OP,  RB
|
|.define TMP1, rsi
|.define TMP2, rdi
|.define TMP3, r9
|
|.if X64WIN
| // On Win64, the first four integer arguments are passed in registers. Integer values are passed 
| // (in order left to right) in RCX, RDX, R8, and R9. Arguments five and higher are passed 
| // on the stack. All arguments are right-justified in registers. This is done so the callee 
| // can ignore the upper bits of the register if need be and can access only the portion 
| // of the register necessary.
| // Floating-point and double-precision arguments are passed in XMM0 - XMM3 (up to 4) 
| // with the integer slot (RCX, RDX, R8, and R9) that would normally be used for that cardinal 
| // slot being ignored (see example below) and vice versa.
| //   func3(int a, double b, int c, float d);    
| //   a in RCX, b in XMM1, c in R8, d in XMM3
| // For functions not fully prototyped, the caller will pass integer values as integers 
| // and floating-point values as double precision. For floating-point values only, both 
| // the integer register and the floating-point register will contain the float value 
| // in case the callee expects the value in the integer registers.
|.define CARG1,		rcx		// x64/WIN64 C call arguments.
|.define CARG2,		rdx
|.define CARG3,		r8
|.define CARG4,		r9
|.define CARG1d,	ecx
|.define CARG2d,	edx
|.define CARG3d,	r8d
|.define CARG4d,	r9d
|.else
|.define CARG1,		rdi		// x64/POSIX C call arguments.
|.define CARG2,		rsi
|.define CARG3,		rdx
|.define CARG4,		rcx
|.define CARG5,		r8
|.define CARG6,		r9
|.define CARG1d,	edi
|.define CARG2d,	esi
|.define CARG3d,	edx
|.define CARG4d,	ecx
|.define CARG5d,	r8d
|.define CARG6d,	r9d
|.endif
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State, rbp
|.type GL,		global_State
|.type TOP,   TValue        // L->top (calls/open ops).
|.type CI,    CallInfo, r12      // L->ci (calls, locally).
|.type LCL,   LClosure, r13      // func->value (calls).
|
|// Type definitions with local validity.
|.type LUASTATE,  lua_State
|.type TVALUE,    TValue
|.type VALUE,   Value
|.type CINFO,   CallInfo
|.type GCOBJECT,  GCObject
|.type TSTRING,   TString
|.type TABLE,   Table
|.type CCLOSURE,  CClosure
|.type LCLOSURE,  LClosure
|.type PROTO,   Proto
|.type UPVAL,   UpVal
|.type NODE,    Node

|// Stack layout while in interpreter. 
|//-----------------------------------------------------------------------
|.if X64WIN		// x64/Windows stack layout
|
|.define CFRAME_SPACE,	aword*5			// Delta for rsp (see <--).
|.macro saveregs_
|  // The registers RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15 are considered nonvolatile 
|  // and must be saved and restored by a function that uses them.
|  // There is always space to hold all parameters in the parameter area of the stack
|  // so that each register parameter has a home address. Even if a function has less
|  // than 4 parameters, at least 4 stack locatons is guaranteed and is owned by the
|  // called function even if it doesn't use it 
|  // All memory beyond the current address of RSP is considered volatile.
|  // A frame function is a function that allocates stack space, calls other functions, 
|  // saves nonvolatile registers, or uses exception handling. It also requires a 
|  // function table entry. A frame function requires a prolog and an epilog.
|  // home location for RCX is [RSP + 8]
|  // home location for RDX is [RSP + 16]
|  // home location for R8 is [RSP + 24]
|  // home location for R9 is [RSP + 32]
|  push rdi; push rsi; push rbx
|  push r12; push r13; push r14; push r15;
|  sub rsp, CFRAME_SPACE
|.endmacro
|.macro saveregs
|  push rbp; saveregs_
|.endmacro
|.macro restoreregs
|  add rsp, CFRAME_SPACE
|  pop r15; pop r14; pop r13; pop r12;
|  pop rbx; pop rsi; pop rdi; pop rbp
|.endmacro
|
|//-----------------------------------------------------------------------
|.else			// x64/POSIX stack layout
|
|.define CFRAME_SPACE,	aword*5			// Delta for rsp (see <--).
|.macro saveregs_
|  push rbp; push rbx; push r15; push r14; 
|  push r13; push r12
|  sub rsp, CFRAME_SPACE
|.endmacro
|.macro saveregs
|  push rbp; saveregs_
|.endmacro
|.macro restoreregs
|  add rsp, CFRAME_SPACE
|  pop r12; pop r13
|  pop r14; pop r15; pop rbx; pop rbp
|.endmacro
|
|.endif

// Instruction decode+dispatch 
|.macro ins_NEXT
|  mov RC, [PC]                                 // Fetch next instruction
|  movzx OP, RCL                                // OP = OpCode
|  add PC, 8                                    // PC++
|  jmp aword [DISPATCH+OP*8]                    // jump to assembly routine 
|.endmacro
|.define ins_next, ins_NEXT

// Following macros decode the bytecode values A, B, C, etc.
// They assume that RC holds the bytecode  
|.macro ins_ABC
|  movzx RA, RCH                                // RA = A
|  shr RC, 16                                   // RC = RC >> 16, now contains B,C
|  movzx RB, RCH
|  movzx RC, RCL; 
|.endmacro
|.macro ins_AB_
|  movzx RA, RCH                                // RA = A
|  shr RC, 16                                   // RC = RC >> 16, now contains B,C
|  movzx RB, RCH 
|.endmacro
|.macro ins_A_C
|  movzx RA, RCH                                // RA = A
|  shr RC, 16                                   // RC = RC >> 16, now contains B,C
|  movzx RC, RCL 
|.endmacro

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  |.code_sub
  |
  |//-----------------------------------------------------------------------
  |//-- VM entry point
  |//-----------------------------------------------------------------------
  |->luaV_interp:
  |  saveregs                                   // prologue, save regs and adjust stack pointer
  |  mov L, CARG1                               // save L (arg1)
  |  mov DISPATCH, L->l_G                       // retrieve global_State
  |  add DISPATCH, DISPATCH_OFFSET              // retrieve the dispatch table
  |  mov CI, L->ci                              // save L->ci
  |  mov TVALUE:TMP1, CI->func                  // Get ci->func
  |  mov LCL, TVALUE:TMP1->value_.gc            // LCL = (LClosure *)(ci->func->value_.gc) 
  |  mov BASE, CI->u.l.base                     // BASE = ci->u.l.base (volatile)
  |  mov PC, CI->u.l.savedpc                    // PC = CI->u.l.savedpc 
  |  ins_next                                   // Fetch instruction, increment PC and go to fetched instruction's label 
  |
  |//-----------------------------------------------------------------------
  |//-- Return handling ----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |//->vm_leave_unw:
  |//  restoreregs
  |//  ret
}

static void build_OP_RETURN(BuildCtx *ctx)
{
  |// Upon entry eax has B,C
  |// RA ecx has A, RB edx has OpCode
  | 
  | mov KBASE, RCa                             // Save the bytecode into KBASE as we don't need KBASE anymore
  | mov PROTO:TMP1, LCL->p                      // TMP1 = ci->p
  | cmp dword PROTO:TMP1->sizep, 0             // Test ci->p->sizep == 0
  | jle >1                                     // Skip call to luaF_close
  |
  | // Call luaF_close
  | // TODO save BASE onto stack
  | mov CARG1, L                               // arg1 = L
  | mov CARG2, BASE                            // arg2 = base
  | call extern luaF_close                     // call luaF_close
  | // TODO restore BASE
  |
  |1: 
  | mov RCa, KBASE
  | ins_AB_                                    // RA = A, RB = B
  |
  | restoreregs
  | ret
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, OpCode op, int defop)
{
  int vk = 0;
  |=>defop:

  switch (op) {
  case OP_RETURN:
    build_OP_RETURN(ctx);
    break;

  /* ---------------------------------------------------------------------- */

  default:
    |  ins_next
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;
  dasm_growpc(Dst, NUM_OPCODES);
  build_subroutines(ctx);
  |.code_op
  for (op = 0; op < NUM_OPCODES; op++)
    build_ins(ctx, (OpCode)op, op);
  return NUM_OPCODES;
}

